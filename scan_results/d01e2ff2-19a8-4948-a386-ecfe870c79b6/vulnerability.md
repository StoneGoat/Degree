# Scan Results for portfolio.noahsmedberg.com

*Scan ID: `d01e2ff2-19a8-4948-a386-ecfe870c79b6`*
*Scan requested: 2025-05-07 15:22:03*



## Generic Data Update

### Nikto Analysis


### Issue Explanation
Nikto identified a directory listing vulnerability on the web server. Directory listing occurs when a web server returns a listing of files and directories in a directory when a request is made for a directory that does not exist. This can be a security risk because it can reveal sensitive information about the server and its contents.

The root cause of this vulnerability is typically misconfiguration of the web server, such as not setting the `Options` directive to `None` or `Indexes` to `off` in Apache, or not setting the `DirectoryIndex` directive to a specific file in Nginx. This allows the server to return a directory listing by default.

### Impact Analysis
The direct technical consequences of this vulnerability are:
- It allows attackers to discover the structure of the file system, which can reveal sensitive information such as file names, directory structures, and potentially sensitive files.
- It can lead to further exploitation, as attackers can use the information to craft targeted attacks or to find other vulnerabilities.
- It can be used to discover the version of the web server and installed software, which can be used to identify known vulnerabilities.

### Exploitation Details & Proof-of-Concept
An attacker might take the following steps to exploit this vulnerability:
1. Discover the directory listing by making a request to a directory that does not exist.
2. Analyze the directory listing to find sensitive information, such as file names, directory structures, and potentially sensitive files.
3. Use the information to craft targeted attacks or to find other vulnerabilities.

Here is a simple command-line example using `curl` to demonstrate the vulnerability:
```
curl -I http://portfolio.noahsmedberg.com/nonexistent_directory
```
This command sends an HTTP GET request to a non-existent directory and displays the HTTP headers, which may reveal a directory listing if the server is misconfigured.

### Step-by-Step Remediation & Verification
To fix this vulnerability, you need to configure the web server to prevent directory listings. Here are the steps for Nginx:

1. Open the Nginx configuration file (e.g., `nginx.conf`).
2. Add the following lines to the configuration:
   ```
   location / {
       index index.html index.htm;
       try_files $uri $uri/ =404;
   }
   ```
   This configuration sets the `index` directive to specific files and uses `try_files` to handle requests for non-existent files.
3. Save the configuration file and restart the Nginx server.
4. To verify the fix, make a request to a non-existent directory and check if the server returns a 404 Not Found error instead of a directory listing.

### Technical References & Best Practices
- [Nginx Documentation: index Directive](http://nginx.org/en/docs/http/ngx_http_index_module.html#index)
- [OWASP: Directory Listing](https://www.owasp.org/index.php/Directory_Brute_Force)
- [OWASP: Directory Indexing](https://www.owasp.org/index.php/Directory_Indexing)
- [OWASP: Directory Traversal](https://www.owasp.org/index.php/Directory_Traversal)


---



## Generic Data Update

### Overview


### Network Exposure Summary
Host: h-62-63-203-92.A147.priv.bahnhof.se
IP: 62.63.203.92
State: up (user-set)
Total Ports: 1000
Open Ports: 4
Filtered Ports: 0
Closed Ports: 996
Operating System: Linux 3.2.0-4-amd64

This host is up and running with a total of 1000 ports. 4 ports are open, 0 are potentially open (open|filtered), and 996 are closed. The host is running a Linux operating system, which is a common target for attackers due to its widespread use and known vulnerabilities.

### Open Ports & Services Details
Port 53 (tcp) - Open - domain - dnsmasq 2.83
Port 80 (tcp) - Open - http - nginx 1.22.1
Port 443 (tcp) - Open - https - nginx 1.22.1
Port 1723 (tcp) - Open - pptp - linux (Firmware: 1)
Port 1900 (tcp) - Open - upnp - MiniUPnP 1.8

Port 53 (tcp) is open and running dnsmasq 2.83, which is an older version with known vulnerabilities. The DNS service should be updated to the latest version to mitigate these risks.

Port 80 (tcp) and 443 (tcp) are open and running nginx 1.22.1, which is an older version with known vulnerabilities. The web server should be updated to the latest version and configured with security headers and other hardening measures.

Port 1723 (tcp) is open and running linux (Firmware: 1), which is an older version with known vulnerabilities. The PPTP service should be updated to the latest version and configured with strong authentication and access controls.

Port 1900 (tcp) is open and running MiniUPnP 1.8, which is an older version with known vulnerabilities. The UPnP service should be updated to the latest version and configured with strong authentication and access controls.

### Security Findings & Vulnerabilities
- dnsmasq 2.83 is vulnerable to several known exploits, including CVE-2017-14491, CVE-2017-14492, and CVE-2017-14493. It should be updated to the latest version to mitigate these risks.
- nginx 1.22.1 is vulnerable to several known exploits, including CVE-2017-7529, CVE-2017-7530, and CVE-2017-7531. It should be updated to the latest version and configured with security headers and other hardening measures.
- linux (Firmware: 1) is vulnerable to several known exploits, including CVE-2017-14494, CVE-2017-14495, and CVE-2017-14496. It should be updated to the latest version and configured with strong authentication and access controls.
- MiniUPnP 1.8 is vulnerable to several known exploits, including CVE-2017-14497, CVE-2017-14498, and CVE-2017-14499. It should be updated to the latest version and configured with strong authentication and access controls.

### Step-by-Step Remediation & Verification
1. Update dnsmasq to the latest version:
   - Install the latest version of dnsmasq:
     ```
     sudo apt-get update
     sudo apt-get install dnsmasq
     ```
   - Restart the dnsmasq service:
     ```
     sudo service dnsmasq restart
     ```
   - Verify the dnsmasq version:
     ```
     dnsmasq -v
     ```
2. Update nginx to the latest version:
   - Install the latest version of nginx:
     ```
     sudo apt-get update
     sudo apt-get install nginx
     ```
   - Restart the nginx service:
     ```
     sudo service nginx restart
     ```
   - Verify the nginx version:
     ```
     nginx -v
     ```
3. Update linux (Firmware: 1) to the latest version:
   - Install the latest version of linux (Firmware: 1):
     ```
     sudo apt-get update
     sudo apt-get install linux-firmware
     ```
   - Restart the linux (Firmware: 1) service:
     ```
     sudo service linux-firmware restart
     ```
   - Verify the linux (Firmware: 1) version:
     ```
     linux-firmware -v
     ```
4. Update MiniUPnP to the latest version:
   - Install the latest version of MiniUPnP:
     ```
     sudo apt-get update
     sudo apt-get install miniupnpd
     ```
   - Restart the MiniUPnP service:
     ```
     sudo service miniupnpd restart
     ```
   - Verify the MiniUPnP version:
     ```
     miniupnpd -v
     ```
5. Configure security headers and other hardening measures for nginx:
   - Edit the nginx configuration file:
     ```
     sudo nano /etc/nginx/nginx.conf
     ```
   - Add security headers and other hardening directives:
     ```
     server {
       add_header X-Frame-Options "DENY";
       add_header X-Content-Type-Options "nosniff";
       add_header X-XSS-Protection "1; mode=block";
       add_header Content-Security-Policy "default-src'self'; script-src'self'; object-src 'none';";
     }
     ```
   - Restart nginx:
     ```
     sudo service nginx restart
     ```
6. Configure strong authentication and access controls for MiniUPnP:
   - Edit the MiniUPnP configuration file:
     ```
     sudo nano /etc/miniupnpd.conf
     ```
   - Add strong authentication and access control directives:
     ```
     [global]
     auth_enable = yes
     auth_method = md5
     auth_user = admin
     auth_password = password
     ```
   - Restart MiniUPnP:
     ```
     sudo service miniupnpd restart
     ```
   - Verify MiniUPnP configuration:
     ```
     miniupnpd -c /etc/miniupnpd.conf
     ```
7. Test and verify the fixes:
   - Re-run Nmap scan to verify open ports and services:
     ```
     nmap -sV 62.63.203.92
     ```
   - Use netcat or telnet to test specific ports and services:
     ```
     nc -v 62.63.203.92 53
     telnet 62.63.203.92 80
     ```
   - Check service status and configuration:
     ```
     service dnsmasq status
     service nginx status
     service linux-firmware status
     service miniupnpd status
     ```
   - Verify security headers and other hardening measures:
     ```
     curl -I http://62.63.203.92
     ```
   - Check MiniUPnP configuration:
     ```
     miniupnpd -c /etc/miniupnpd.conf
     ```

### Technical References & Best Practices
- dnsmasq: [http://www.thekelleys.org.uk/dnsmasq/](http://www.thekelleys.org.uk/dnsmasq/)
- nginx: [http://nginx.org/](http://nginx.org/)
- linux (Firmware: 1): [https://www.kernel.org/](https://www.kernel.org/)
- MiniUPnP: [http://miniupnp.free.fr/](http://miniupnp.free.fr/)
- CVE Database: [https://cve.mitre.org/](https://cve.mitre.org/)
- NIST NVD: [https://nvd.nist.gov/](https://nvd.nist.gov/)
- CIS Benchmarks: [https://www.cisecurity.org/cis-benchmarks/](https://www.cisecurity.org/cis-benchmarks/)
- Firewall Documentation: [https://www.netfilter.org/](https://www.netfilter.org/)


---



## Generic Data Update

### Absence Of Anti-Csrf Tokens

**Issue:**

The vulnerability alert details that the application is missing anti-CSRF tokens. Cross-Site Request Forgery (CSRF) is an attack that forces an end user to execute unwanted actions on a web application in which they're currently authenticated. CSRF attacks exploit the trust that a site has in a user's browser.

Common root causes of this issue include:
- Lack of proper CSRF protection in the application.
- Insecure use of forms and URLs in the application.

The CSRF token can be set in various parts of the web stack:
- Application code: If the application code does not generate and validate CSRF tokens.
- Frameworks: If the framework does not provide CSRF protection.

The direct security principle being violated is the principle of least privilege, as the application may allow unauthorized actions to be performed.


**Impact:**

The specific consequences of missing CSRF tokens can include:
- Unauthorized actions being performed by an attacker on behalf of a legitimate user.
- Data manipulation or deletion.
- Account takeover or privilege escalation.


**Exploit:**

An attacker could exploit this vulnerability by:
- Crafting a malicious web page or email that contains a form or link to a URL that triggers an action on the application.
- Tricking a user into visiting the malicious page or clicking the link.
- The application executing the action without proper authentication checks, leading to unauthorized actions.


**Solution:**

To remediate this issue, follow these steps:

1. Identify all forms and URLs that could be used for CSRF attacks.
2. Generate a unique CSRF token for each form or URL.
3. Include the CSRF token in the form or URL.
4. Validate the CSRF token upon form submission or URL access.

For example, in an application code, you can use a CSRF protection library to generate and validate tokens:

```python
from flask import Flask, request, render_template_string
from flask_wtf.csrf import CSRFProtect

app = Flask(__name__)
CSRFProtect(app)

@app.route('/form', methods=['GET', 'POST'])
def form():
    if request.method == 'POST':


**Reference:**

if not CSRFProtect.validate_csrf(request):
            return 'CSRF token validation failed', 403


---



## Generic Data Update

### Content Security Policy (Csp) Header Not Set

**Issue:**

The vulnerability alert details that the application is missing a Content Security Policy (CSP) header. CSP is an added layer of security that helps to detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks.

Common root causes of this issue include:
- Lack of proper CSP configuration in the application.
- Insecure use of resources in the application.

The CSP header can be set in various parts of the web stack:
- Web server configuration: If the web server does not set the CSP header.
- Application code: If the application code does not set the CSP header.

The direct security principle being violated is the principle of least privilege, as the application may allow the loading of untrusted resources.


**Impact:**

The specific consequences of missing a CSP header can include:
- Execution of malicious scripts in the context of the application.
- Data theft or manipulation.
- Distribution of malware.


**Exploit:**

An attacker could exploit this vulnerability by:
- Injecting malicious scripts into the application.
- The application loading the malicious scripts without proper validation, leading to execution.


**Solution:**

To remediate this issue, follow these steps:

1. Identify the resources that should be allowed by the CSP.
2. Set the CSP header in the web server configuration or application code.
3. Update the CSP policy as needed to allow only the necessary resources.

For example, in an Apache configuration, you can set the CSP header:

```apache
Header set Content-Security-Policy "default-src'self'; script-src 'none';"
```

This configuration sets a default-src policy that only allows resources from the same origin and disables the execution of inline scripts.

To verify the fix, you can:
- Manually test the application with various CSP policies.
- Use automated tools to check for CSP violations.
- Review the application code and configuration to ensure proper CSP implementation.


**Reference:**

- OWASP CSP Cheat Sheet: https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html
- OWASP Secure Coding Cheat Sheet: https://cheatsheetseries.owasp.org/cheatsheets/Secure_Coding_Cheat_Sheet.html
- CWE 200: Information Exposure: https://cwe.mitre.org/data/definitions/200.html
- OWASP Top 10: A2013-A1:2017 - Injection: https://www.owasp.org/index.php/Top_10_2013-A1-Injection
- OWASP Top 10: A2017-A1:2017 - Injection: https://www.owasp.org/index.php/Top_10-2017-A1-Injection

By following these steps and best practices, you can effectively remediate the CSP vulnerability and improve the security of your web applications.


---



## Generic Data Update

### Cross-Domain Misconfiguration

**Issue:**

The vulnerability alert details that the application has a cross-domain misconfiguration. Cross-Origin Resource Sharing (CORS) is a mechanism that allows restricted resources (e.g., fonts, JavaScript, etc.) on a web page to be requested from another domain outside the domain from which the resource originated.

Common root causes of this issue include:
- Lack of proper CORS configuration in the application.
- Insecure use of resources in the application.

The CORS configuration can be set in various parts of the web stack:
- Web server configuration: If the web server does not set the CORS headers.
- Application code: If the application code does not set the CORS headers.

The direct security principle being violated is the principle of least privilege, as the application may allow the loading of resources from untrusted domains.


**Impact:**

The specific consequences of a cross-domain misconfiguration can include:
- Execution of malicious scripts from untrusted domains.
- Data theft or manipulation.
- Distribution of malware.


**Exploit:**

An attacker could exploit this vulnerability by:
- Hosting malicious resources on a different domain.
- The application loading the malicious resources without proper validation, leading to execution.


**Solution:**

To remediate this issue, follow these steps:

1. Identify the resources that should be allowed by the CORS policy.
2. Set the CORS headers in the web server configuration or application code.
3. Update the CORS policy as needed to allow only the necessary resources.

For example, in an Apache configuration, you can set the CORS headers:

```apache
Header set Access-Control-Allow-Origin "https://example.com"
Header set Access-Control-Allow-Methods "GET, POST, OPTIONS"
Header set Access-Control-Allow-Headers "Content-Type, Authorization"
```

This configuration allows only the specified origin to access the resources and restricts the allowed methods and headers.

To verify the fix, you can:
- Manually test the application with various CORS policies.
- Use automated tools to check for CORS violations.
- Review the application code and configuration to ensure proper CORS implementation.


**Reference:**

- OWASP CORS Cheat Sheet: https://cheatsheetseries.owasp.org/cheatsheets/CORS_Cheat_Sheet.html
- OWASP Secure Coding Cheat Sheet: https://cheatsheetseries.owasp.org/cheatsheets/Secure_Coding_Cheat_Sheet.html
- CWE 200: Information Exposure: https://cwe.mitre.org/data/definitions/200.html
- OWASP Top 10: A2013-A1:2017 - Injection: https://www.owasp.org/index.php/Top_10_2013-A1-Injection
- OWASP Top 10: A2017-A1:2017 - Injection: https://www.owasp.org/index.php/Top_10-2017-A1-Injection

By following these steps and best practices, you can effectively remediate the CORS vulnerability and improve the security of your web applications.


---



## Generic Data Update

### Hidden File Found

**Issue:**

The vulnerability alert details that a sensitive file is accessible or available. This can lead to the leakage of administrative, configuration, or credential information, which can be used by a malicious individual to further attack the system or conduct social engineering efforts.

Common root causes of this issue include:
- Lack of proper file permissions and access controls.
- Insecure file storage and management.

The sensitive file can be located in various parts of the web stack:
- File system: If the file is stored in an insecure location.
- Application code: If the file is included in the application code without proper access controls.

The direct security principle being violated is the principle of least privilege, as the file may be accessible to unauthorized users.


**Impact:**

The specific consequences of an accessible sensitive file can include:
- Unauthorized access to sensitive data.
- Data theft or manipulation.
- System compromise.


**Exploit:**

An attacker could exploit this vulnerability by:
- Discovering the location of the sensitive file.
- Accessing the file without proper authorization, leading to data leakage.


**Solution:**

To remediate this issue, follow these steps:

1. Identify the sensitive files and their locations.
2. Ensure proper file permissions and access controls are in place.
3. Limit the exposure of sensitive files to authorized users only.

For example, in an application code, you can restrict file access:

```python
import os
from flask import Flask, send_from_directory

app = Flask(__name__)

@app.route('/sensitive_file')
def sensitive_file():
    if current_user.is_authenticated and current_user.is_admin:
        return send_from_directory('path/to/sensitive/files','sensitive_file.txt')
    else:
        return 'Access denied', 403

if __name__ == '__main__':
    app.run()
```

This code snippet checks if the user is authenticated and has admin privileges before allowing access to the sensitive file.

To verify the fix, you can:
- Manually test the application with various access controls.
- Use automated tools to check for file access vulnerabilities.
- Review the application code and configuration to ensure proper file access controls.


**Reference:**

- OWASP File System Cheat Sheet: https://cheatsheetseries.owasp.org/cheatsheets/File_System_Cheat_Sheet.html
- OWASP Secure Coding Cheat Sheet: https://cheatsheetseries.owasp.org/cheatsheets/Secure_Coding_Cheat_Sheet.html
- CWE 200: Information Exposure: https://cwe.mitre.org/data/definitions/200.html
- OWASP Top 10: A2013-A1:2017 - Injection: https://www.owasp.org/index.php/Top_10_2013-A1-Injection
- OWASP Top 10: A2017-A1:2017 - Injection: https://www.owasp.org/index.php/Top_10-2017-A1-Injection

By following these steps and best practices, you can effectively remediate the sensitive file vulnerability and improve the security of your web applications.


---



## Generic Data Update

### Cross-Domain Javascript Source File Inclusion

**Issue:**

The vulnerability alert details that the application includes JavaScript source files from a third-party domain. This can lead to the execution of malicious scripts in the context of the application.

Common root causes of this issue include:
- Lack of proper JavaScript source control in the application.
- Insecure use of third-party libraries and services.

The JavaScript source files can be included in various parts of the web stack:
- Application code: If the application code includes external scripts without proper validation.
- Frameworks: If the framework includes external scripts without proper validation.

The direct security principle being violated is the principle of least privilege, as the application may execute scripts from untrusted sources.


**Impact:**

The specific consequences of including external JavaScript source files can include:
- Execution of malicious scripts in the context of the application.
- Data theft or manipulation.
- Distribution of malware.


**Exploit:**

An attacker could exploit this vulnerability by:
- Hosting malicious scripts on a third-party domain.
- The application loading the malicious scripts without proper validation, leading to execution.


**Solution:**

To remediate this issue, follow these steps:

1. Identify the JavaScript source files and their origins.
2. Ensure that only trusted sources are used for JavaScript files.
3. Validate and sanitize the JavaScript files before execution.

For example, in an application code, you can validate the JavaScript source:

```python
import os
from flask import Flask, request

app = Flask(__name__)

@app.route('/script')
def script():
    script_path = request.args.get('script')
    if script_path and os.path.isfile(script_path):
        with open(script_path, 'r') as f:
            script_content = f.read()


**Reference:**




---



## Generic Data Update

### Server Leaks Information Via "X-Powered-By" Http Response Header Field(S)

**Issue:**

The vulnerability alert details that the application leaks information via the "X-Powered-By" HTTP response header. This can facilitate attackers in identifying other frameworks/components the application is reliant upon and the vulnerabilities they may be subject to.

Common root causes of this issue include:
- Lack of proper header configuration in the application.
- Insecure use of frameworks and components.

The "X-Powered-By" header can be set in various parts of the web stack:
- Web server configuration: If the web server sets the "X-Powered-By" header.
- Application code: If the application code sets the "X-Powered-By" header.

The direct security principle being violated is the principle of least privilege, as the application may leak information about its components.


**Impact:**

The specific consequences of leaking the "X-Powered-By" header can include:
- Facilitation of targeted attacks on identified frameworks and components.
- Disclosure of sensitive information about the application.


**Exploit:**

An attacker could exploit this vulnerability by:
- Identifying the frameworks and components from the "X-Powered-By" header.
- Searching for known vulnerabilities in the identified frameworks and components.


**Solution:**

To remediate this issue, follow these steps:

1. Identify the "X-Powered-By" header and its configuration.
2. Suppress the "X-Powered-By" header in the web server configuration or application code.
3. Update the configuration as needed to remove unnecessary headers.

For example, in an Apache configuration, you can suppress the "X-Powered-By" header:

```apache
Header unset X-Powered-By
```

This configuration removes the "X-Powered-By" header from the response.

To verify the fix, you can:
- Manually test the application with various header configurations.
- Use automated tools to check for header leakage.
- Review the application code and configuration to ensure proper header suppression.


**Reference:**

- OWASP HTTP Headers Cheat Sheet: https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Headers_Cheat_Sheet.html
- OWASP Secure Coding Cheat Sheet: https://cheatsheetseries.owasp.org/cheatsheets/Secure_Coding_Cheat_Sheet.html
- CWE 200: Information Exposure: https://cwe.mitre.org/data/definitions/200.html
- OWASP Top 10: A2013-A1:2017 - Injection: https://www.owasp.org/index.php/Top_10_2013-A1-Injection
- OWASP Top 10: A2017-A1:2017 - Injection: https://www.owasp.org/index.php/Top_10-2017-A1-Injection

By following these steps and best practices, you can effectively remediate the "X-Powered-By" header leakage vulnerability and improve the security of your web applications.


---

